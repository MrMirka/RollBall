<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BB Smooth Scrolling</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.1.2/fullpage.css">
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.1.2/fullpage.js"></script>
    <script src="https://threejs.org/build/three.js"></script>
</head>

<body>
    <script type="module">
            import { GLTFLoader } from './threejs-dev/examples/jsm/loaders/GLTFLoader.js';
			import { OrbitControls } from './threejs-dev/examples/jsm/controls/OrbitControls.js';
            import { RGBELoader } from './threejs-dev/examples/jsm/loaders/RGBELoader.js';
            import { RoughnessMipmapper } from './threejs-dev/examples/jsm/utils/RoughnessMipmapper.js';

            var clock = new THREE.Clock(); //Системные часы
            var GoBall = false; //Состояник качения
            var ScrollUP=false; //Скролл вверх
            var ScrollDown=false; //Скролл вниз
            var frameTimer=0; //Счетчик кадров
            var shadowMesh; //Тень сферы

            var Ray = true;

            var BallRadius=0;

          
            const renderer = new THREE.WebGLRenderer({alpha: true });
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera( 750, window.innerWidth / window.innerHeight, 0.1, 1000 );
            
            const screenV = new THREE.Vector3();
            
            //+++++++++++++++++TEST RAY++++++++++++++++++++++++++
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2(0,1);

            function onMouseMove( event ) {
                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
            }
            
            init();
            loadMesh();

            //Inicilization scene
            function init(){    
		    	renderer.setSize( window.innerWidth, window.innerHeight );
		    	renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
		    	renderer.shadowMap.enabled = true;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
			    renderer.toneMappingExposure = 1;
			    renderer.outputEncoding = THREE.sRGBEncoding;
			    document.body.appendChild( renderer.domElement );
                
                //set ligth
                const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
                directionalLight.position.set( 2, 8, 4 );
                directionalLight.shadow.mapSize.width = 2048; 
                directionalLight.shadow.mapSize.height = 2048; 
                directionalLight.shadow.radius = 20;
                directionalLight.shadow.camera.far = 20;
                scene.add( directionalLight );

                const light = new THREE.AmbientLight( 0x404040 ); // soft white light
                scene.add( light ); 

                //+++++++++++++++++++++SHADOW IMAGE TEXTURE LOADER++++++++++++++++++++++++++++
                const textureLoader = new THREE.TextureLoader();
                const blendings = [
                        { name: 'No', constant: THREE.NoBlending },
                        { name: 'Normal', constant: THREE.NormalBlending },
                        { name: 'Additive', constant: THREE.AdditiveBlending },
                        { name: 'Subtractive', constant: THREE.SubtractiveBlending },
                        { name: 'Multiply', constant: THREE.MultiplyBlending }
                    ];

                const map = textureLoader.load( './img/shadow.png' );	
                const geo = new THREE.PlaneGeometry( 1.3, 1.3 );
                addImage(map);


                function addImage( map) {
                        const blending = blendings[ 1 ];
                        const material = new THREE.MeshBasicMaterial( { map: map } );
                        material.transparent = true;
                        material.blending = blending.constant;
                        shadowMesh = new THREE.Mesh( geo, material );
                        shadowMesh.position.set( 0, -0.2, 0 );
                        shadowMesh.rotation.x = -1.5708;
                        scene.add( shadowMesh );		
                }



                
                //set camera position
                camera.rotation.x=-1.5708;
		    	camera.position.set( 0, 5 , 0 );
                renderer.render( scene, camera );
            }

            function loadMesh(){

                screenV.project( camera );
                /*screenV.x = ( screenV.x + 1) * window.innerWidth / 2;
                screenV.y = - ( screenV.y - 1) * window.innerHeight / 2;
                screenV.z = 0;*/
               // console.log("Screen "+screenV.x+" "+screenV.z);

                const meshLoader = new GLTFLoader();
                const roughnessMipmapper = new RoughnessMipmapper( renderer );
                meshLoader.load( './mesh/ball-lp2.glb', function ( gltf ) { 
				gltf.scene.name = 'ball';
				//gltf.scene.castShadow=true;
				//gltf.scene.receiveShadow=true;
				gltf.scene.traverse( function( node ) {
					if ( node.isMesh ) {
						roughnessMipmapper.generateMipmaps( node.material );
                    }
				} );
                scene.add( gltf.scene );
                renderer.render( scene, camera );
                const hdri = new RGBELoader();
				hdri.load( './img/oberer_kuhberg_4k.pic', function ( texture ) {
					texture.mapping = THREE.EquirectangularReflectionMapping;
					scene.environment = texture;
					renderer.render( scene, camera );
				});

                const animate = function () {
                    
                   

                    mouse.y-=0.003;
                    //++++++++RAY++++++++++++++
                    function render() {

                        // update the picking ray with the camera and mouse position
                        raycaster.setFromCamera( mouse, camera );

                        // calculate objects intersecting the picking ray
                        const intersects = raycaster.intersectObjects( gltf.scene.children, true);
                        //console.log("RAYs2 "+intersects.far);

                        for ( let i = 0; i < intersects.length; i ++ ) {
                            //intersects[ i ].object.material.color.set( 0xff0000 );
                            if(Ray){BallRadius=Math.abs(mouse.y) ;Ray=false; };
                        }
                        renderer.render( scene, camera );

                    }
                    //+++++++++++++++++++++++++
                    if(BallRadius>0){console.log("BALL ROTATION "+getRotationCount(BallRadius));};
                    if(GoBall){
                       if(ScrollUP){ 
                        gltf.scene.rotation.x=CubicInOut(frameTimer,0,15.708,59);
                         //gltf.scene.rotation.x=CubicInOut(frameTimer,0,getRotationCount(BallRadius),59);
                       }else if(ScrollDown){
                        //gltf.scene.rotation.x=getRotationCount(BallRadius)-CubicInOut(frameTimer,0,getRotationCount(BallRadius),59);
                        gltf.scene.rotation.x=15.708-CubicInOut(frameTimer,0,15.708,59);
                       }
                       frameTimer+=1;
                       //При анимации дольше 1 сек останавливаем кручение мяча и обнудяем все триггеры
                       if(clock.getElapsedTime()>1){
                            GoBall=false;
                            ScrollUP=false;
                            ScrollDown=false; 
                            frameTimer=0;
                       }
                    }
                    render();
                    requestAnimationFrame( animate );
                    renderer.render( scene, camera );
                }

                animate();

                window.addEventListener("wheel", function(e) {
                        if(isUp(e.deltaY)){
                            ScrollUP=true;
                            ScrollDown=false;
                        }else{
                            ScrollUP=false;
                            ScrollDown=true;
                        }
                        if(!GoBall){    
                             clock.start();	
                             GoBall=true;
                        }	
						}, true);
                
                }, undefined, function ( error ) {
                     console.error( error );	
               });
               
             }

             window.addEventListener("resize", function(e) {
                    UpdateWindow();
						}, true);
            //window.addEventListener( 'mousemove', onMouseMove, false );            

             //Проверка направления скролла
             function isUp(deltaY){
                if(deltaY>0) {
                    return true;
                }else {
                    return false;
                }
	    	};

            //t - current time
            //b - start value
            //c - change value
            //d - duration
            function CubicInOut(t, b, c, d){
                if ((t /= d / 2) < 1) return c / 2 * t * t * t + b;
                return c / 2 * ((t -= 2) * t * t + 2) + b;
            }

            //Вычисляем количество оборотов мяча
            function getRotationCount(radius){
                //console.log("VOLUME- "+getVolume(radius)+" DATA "+radius + " COUNT "+2/getVolume(radius));
                return (2/getVolume(radius))*6.28319;
            }

            //Вычесляет объем сферы
            function getVolume(radius) {
                let volume=0;
                //volume = (4/3)*(Math.PI * Math.pow(radius, 3));
                volume = 2*Math.PI*radius;
                return volume;
            }
            //Обновляет значения при маштабировании окна
            function UpdateWindow(){
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }


             
             
    </script>
    <div class="container" id="container">
        <section class="section" id="home">
            <h1>BetBoom</h1>
            <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Ad saepe quia eaque laboriosam deserunt vero?
            </p>
        </section>
        <section class="section" id="about">
            <h1>Заголовок</h1>
            <p>Lorem ipsum dolor sit amet consectetur, adipisicing elit. Ad saepe quia eaque laboriosam deserunt vero?
            </p>
        </section>
    </div>

    <script>
        new fullpage('#container', {
            //options here
            autoScrolling: true,
            scrollHorizontally: false,
            scrollingSpeed: 1000,
            verticalCentered: true,
            easing: 'easeInOutCubic',
        });


        
    </script>
    
</body>

</html>